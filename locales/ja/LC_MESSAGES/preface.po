# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Anders Møller and Michael I. Schwartzbach
# This file is distributed under the same license as the Static Program
# Analysis package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Static Program Analysis \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-02-25 09:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../preface.rst:2
msgid "Preface"
msgstr "前書き"

#: ../../preface.rst:4
msgid ""
"Static program analysis is the art of reasoning about the behavior of "
"computer programs without actually running them. This is useful not only "
"in optimizing compilers for producing efficient code but also for "
"automatic error detection and other tools that can help programmers. A "
"static program analyzer is a program that reasons about the behavior of "
"other programs. For anyone interested in programming, what can be more "
"fun than writing programs that analyze programs?"
msgstr ""
"静的プログラム解析はプログラムを実行することなくその挙動を解析する芸術である。"
"これはコンパイラが効率的なコードに最適化するときだけではなく、自動的にエラーを"
"発見するなどプログラムを助ける道具にも効果的である。静的プログラム解析器は"
"他のプログラムの挙動を解析するプログラムである。"
"プログラミングに関心を持つ者にとって、プログラムを解析するプログラムを書くこと以上に"
"楽しいことがあるだろうか？"

#: ../../preface.rst:11
msgid ""
"As known from Turing and Rice, all nontrivial properties of the behavior "
"of programs written in common programming languages are mathematically "
"undecidable. This means that automated reasoning of software generally "
"must involve approximation. It is also well known that testing, i.e. "
"concretely running programs and inspecting the output, may reveal errors "
"but generally cannot show their absence. In contrast, static program "
"analysis can – with the right kind of approximations – check all possible"
" executions of the programs and provide guarantees about their "
"properties. One of the key challenges when developing such analyses is "
"how to ensure high precision and efficiency to be practically useful. For"
" example, nobody will use an analysis designed for bug finding if it "
"reports many false positives or if it is too slow to fit into real-world "
"software development processes."
msgstr ""
"TuringとRiceによって知られるように、一般的なプログラミング言語で書かれたプログラムの"
"振る舞いに関するすべての非自明な特性は、数学的に決定不可能である。"
"すなわち、ソフトウェアの自動推論には一般的に近似性が求められる。"
"同様にテスト、実際にプログラムを実行して出力を確認する行いは、"
"エラーを発見することはできてもエラーがないことは示せないのが一般的である。"
"これに対し、静的プログラム解析では、適切な近似値を用いることでプログラムのすべての実行可能性をチェックし、その特性を保証できる。"
"このような解析を開発する際の重要な課題のひとつは、実用的な精度と効率をいかにして確保するかである。"
"バグ発見のために開発された解析でも、誤検出が多かったり速度が遅すぎて"
"実際のソフトウェア開発プロセスに適合しないようでは、誰も使わないからである。"

#: ../../preface.rst:24
msgid ""
"These notes present principles and applications of static analysis of "
"programs. We cover basic type analysis, lattice theory, control flow "
"graphs, dataflow analysis, fixed-point algorithms, widening and "
"narrowing, path sensitivity, relational analysis, interprocedural "
"analysis, context sensitivity, control-flow analysis, several flavors of "
"pointer analysis, and key concepts of semantics-based abstract "
"interpretation. A tiny imperative programming language with pointers and "
"first-class functions is subjected to numerous different static analyses "
"illustrating the techniques that are presented. We take a *constraint-"
"based approach* to static analysis where suitable constraint systems "
"conceptually divide the analysis task into a front-end that generates "
"constraints from program code and a back-end that solves the constraints "
"to produce the analysis results. This approach enables separating the "
"analysis specification, which determines its precision, from the "
"algorithmic aspects that are important for its performance. In practice "
"when implementing analyses, we often solve the constraints on-the-fly, as"
" they are generated, without representing them explicitly."
msgstr ""

#: ../../preface.rst:37
msgid ""
"We focus on analyses that are fully automatic (i.e., not involving "
"programmer guidance, for example in the form of loop invariants or type "
"annotations) and conservative (sound but incomplete), and we only "
"consider Turing complete languages (like most programming languages used "
"in ordinary software development)."
msgstr ""

#: ../../preface.rst:41
msgid ""
"The analyses that we cover are expressed using different kinds of "
"constraint systems, each with their own constraint solvers:"
msgstr ""
"私たちが扱う解析はさまざまな種類の制約システムで表現され、それぞれに固有の制約ソルバーを有する:"

#: ../../preface.rst:44
msgid "term unification constraints, with an almost-linear union-find algorithm,"
msgstr ""

#: ../../preface.rst:45
msgid "conditional subset constraints, with a cubic-time algorithm, and"
msgstr ""

#: ../../preface.rst:46
msgid ""
"monotone constraints over lattices, with variations of fixed-point "
"solvers."
msgstr ""

#: ../../preface.rst:48
msgid ""
"The style of presentation is intended to be precise but not overly "
"formal. The readers are assumed to be familiar with advanced programming "
"language concepts and the basics of compiler construction and "
"computability theory."
msgstr ""

#: ../../preface.rst:52
msgid ""
"The notes are accompanied by a web site that provides lecture slides, an "
"implementation (in Scala) of most of the algorithms we cover, and "
"additional exercises: `https://cs.au.dk/˜amoeller/spa/ "
"<https://cs.au.dk/˜amoeller/spa/>`_"
msgstr ""

